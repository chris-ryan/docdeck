<!DOCTYPE html>
<html>
<title>Diabetic Retinopathy CRE - NodeJS</title>
<body>

<!-- Markdown under here -->    
<xmp theme="cerulean" style="display:none;">

### What is Node.JS?

Node is basically a wrapper around the V8 JavaScript runtime (the same one that chrome uses to run JS) to allow us to build JS applications outside of the browser.

Ryan Dhal created Node in 2009. 

**NodeJS is event-driven, non-blocking and modular.**

#### Event-driven
Being event-driven, almost all of the code in Node is written to either respond to an event or itself fire an event. This is essentially the mechanism buy which different Node objects and modules communicate. It also makes Node apps scale very well as many connections can be handled concurrently but if there is no work to be done, Node is sleeping.

#### Blocking vs non-blocking calls
Blocking calls, or synchronous calls, are those where control doesn't return to the application until the requested operation is completed. This commonly occurs in I/O operations. For example, when reading and writing using a blocking call, the application must wait until the read or write operation is done before further logic can be processed. This means that the application is idle while waiting for a potentially lengthy operation to complete.

Non-blocking calls are those where control returns to the application almost immediately, before waiting for the operation to complete. This is called asynchronous programming. The completion of the operation is often communicated to the application via a callback routine. Node uses non-blocking calls along with a queue to priotize tasks and a dispatcher to assign tasks to workers and pass back completed packages.
#### Callbacks
A callback is a piece of executable code that runs in response to a certain event. It is passed as an argument to other code that will execute the callback when specified. Callbacks are often used to notify the application that an I/O operation is complete. For example, timer functions often include a callback function:

```
setTimeout(function() {sys.puts("timer done")}, 1000);
```
In this case, "timer done" will be printed after one second. 

#### Modules




The general principle of Node is that operations should never block. 
This is at the heart of what delivers the high concurrency and effciency.

### Installing Node.js
#### MacOS and Windows
Go to https://nodejs.org/en/ and download and install the "current" installer package.


### Hello World
Create a new file (hello.js) and open it with your favourite editor

```
var http = require('http');

http.createServer(function(request, response) {
    response.writeHead(200); //outputs the status code in the header
    response.write("Hello world, this is Node.JS"); // the body of the response
    response.end(); //close the connection

}).listen(8080);
```

* From your terminal/command line run the server using:
```node hello.js```
* In another terminal/command line window, hit the server to view the response:
```curl http://localhost:8080```
* ctrl + c to stop the node server process.

## Events

Look at the earlier Hello World code.

When its executed, Node goes through the code and registers any known events. 
In this case it registers  *request*.

>> Pop over to the node docs page for the [http module][1] and see the objects within the http.ClientRequest class it considers to be events.

Node then goes into an event loop. Where its continuously checking for the registered events.

In our code, that means node is listening for a 'request' to come in.
When the request is received, node then runs the code in the callback (reponse)'

Let's modify our earlier hello.js, adding a line to log the incoming request by referring to the request.url property.

```
var http = require('http');

http.createServer(function(request, response) {
    response.writeHead(200);
    console.log("Incoming request:" + request.url);
    response.write("Hello world, this is Node.JS");
    response.end();

}).listen(8080);
```
Fire up the node hello.js, go to localhost:8080 in your browser and take a look in your terminal to see the console output.

You'll notice two requests, one for "/" and another for "/favicon.ico". Don't stress about that last one. Whenever you load a url modern browsers look for a corresponding favicon to put a pretty icon in their tabs.

Now try putting in something after "localhost:8080/" in your browser's url bar: Eg: http://localhost:8080/bobsyouruncle

You'll see "Incoming request:/bobsyouruncle" now gets logged to the console. 

This is at the core of how we can use the url property to differentiate incoming requests and serve up different pages in response. 

### Event emmitters

Just as events can be triggered in the DOM (click, submit, load, hover etc..), many objects in Node emit events.
Most of these inherit from the [EventEmitter][2] constructor.
For example, in our Hello World app, the ```http.createServer(function(request, response) {``` method is passed the request event

[1]: https://nodejs.org/api/http.html "NodeJS Docs - http"
[2]: https://nodejs.org/api/events.html#events_class_eventemitter "NodeJS Docs - EventEmitter"

</xmp>
</body>
<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
</html>